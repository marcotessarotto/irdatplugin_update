# -*- coding: utf-8 -*-
"""
/***************************************************************************
 CatalogoIRDATDialog
                                 A QGIS plugin
 Plugin per la consultazione del Catalogo IRDAT
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2019-11-15
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Insiel Spa
        email                : noreply@insiel.it
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import platform

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from PyQt5.QtWidgets import QMessageBox, QTableWidget, QTableWidgetItem 
from PyQt5.QtGui import QStandardItemModel
# from PyQt5.QtWebEngineWidgets import *
from PyQt5 import QtGui

from qgis.PyQt.QtCore import QCoreApplication # per tr

import logging # per log
import traceback
import sys # per log handler
from qgis.core import QgsMessageLog, Qgis
from qgis.core import QgsApplication
import datetime

# REST
import requests

from qgis.core import QgsVectorLayer, QgsProject # per aggiungere il layer
import webbrowser # per web browser
from PyQt5.QtCore import QUrl, QUrlQuery
from PyQt5.QtWebKitWidgets import QWebPage
from PyQt5.QtWebKitWidgets import QWebView

from PyQt5.QtWidgets import QApplication

# gestione thread
from threading import Thread







IRDAT_CATALOG_API                   = 'http://irdat.regione.fvg.it/rs-catalog/api'
FILE_LOG                            = 'qgis.log' # nella cartella Documenti dell'utente  
LIVELLO_LOG                         = {0: "INFO     ", 1: "WARNING  ", 2: "CRITICAL", 3: "SUCCESS  ", 4: "NONE     "} 
LIVELLO_LOG_COMBOBOX                = {0: "Mostra tutti", 1: "Mostra livello INFO", 2: "Mostra livello WARNING", 3: "Mostra livello ERROR"} 
TAB_LOG_QGIS                        = 'IRDAT Explorer 3'
LINGUE                              = {0: "ita", 1: "eng"} # possibili lingue di ricerca su irdat
TIMEOUT                             = 30





# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'catalogo_irdat_dialog_base.ui'))


class CatalogoIRDATDialog(QtWidgets.QDialog, FORM_CLASS):
    
    
    # layer selezionato
    sel_layer_id = None
    sel_layer_title = None
    sel_layer_wfs = None
    sel_item = None
    # sistema operativo
    so_info = ''
    # parametri vari
    language = "ita"
    log_tab_level = 0  
    log_list = [] # lista di supporto per la tab del log


    def __init__(self, parent=None):
        """Constructor."""
        super(CatalogoIRDATDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # recupero info sistema operativo
        self.so_info = str(platform.system()) 
        
        # configurazione tabella elementi IRDAT
        self.tableWidget.setColumnCount(4)
        self.tableWidget.setHorizontalHeaderLabels(['Titolo', 'Abstract','id','WFS'])

        self.tableWidget.setAlternatingRowColors(True)
        self.tableWidget.setSelectionBehavior(QTableWidget.SelectRows)
        self.tableWidget.setSelectionMode(QTableWidget.SingleSelection)
        self.tableWidget.setColumnWidth(0, 200)
        self.tableWidget.setColumnWidth(1, 400)

        # disabilitazione componenti dialog
        self.soggetti_comboBox.setEnabled(False)
        self.testo_lineEdit.setEnabled(False)
        self.ricerca_pushButton.setEnabled(False)
        self.visualizza_metadati_pushButton.setEnabled(False)
        self.carica_layer_pushButton.setEnabled(False)
        self.apri_webbrowser_pushButton.setEnabled(False)
        self.carica_layer_MD_pushButton.setEnabled(False)
        self.status_lineEdit.setEnabled(False)
        self.lingua_comboBox.setEnabled(False)
        self.setStyleSheet(
            '''
            QTableView::item:selected:!active {
                background: #0078d7;
                color: #ffffff;
            }
            '''
        )

        # gestione log
        self.log_tab_level = self.log_comboBox.currentIndex()
        
        def write_log_message(message,tag,level):
            if level==2: # 2=critical/error
                message = message + ' [' + str(sys.exc_info()) + ']'
            msg = '{time} - {tag}: {level} -  {message}'.format(time=datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'), tag=tag, level=LIVELLO_LOG[level], message=message)
            # scrittura su file
            with open(FILE_LOG, 'a') as logfile:
                logfile.write('\n'+msg)
            # scrittura su tab del plugin
            if (self.log_tab_level==0 or level==self.log_tab_level+1):
                self.log_listWidget.addItem(msg)
            # scrittura sulla lista di supporto per la gestione della comboBox
            log_item=[level, msg]
            self.log_list.append(log_item)
            
        QgsApplication.messageLog().messageReceived.connect(write_log_message)
        
        self.message_info("Avvio plugin Catalogo IRDAT Explorer 3")
        # fine: gestione log









##################################################################################################################################
## Utils
##################################################################################################################################


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('CatalogoIRDAT', message)

    def message_info(self,message):
        """Management of info messages.

        :param message: message string.
        :type message: str, QString
        """
        self.status_lineEdit.setText(self.tr(message))
        QgsMessageLog.logMessage(self.tr(message), TAB_LOG_QGIS, level=Qgis.Info)
        print(self.tr(message))

    def message_warning(self,message):
        """Management of warning messages.

        :param message: message string.
        :type message: str, QString
        """
        QMessageBox.warning(None
            , 'WARNING'
            , self.tr(message))
        QgsMessageLog.logMessage(message, TAB_LOG_QGIS, level=Qgis.Warning)
        print('WARNING: '+self.tr(message))
        
    def message_error(self, message):
        """Management of error messages.

        :param message: message string.
        :type message: str, QString
        """        
        QgsMessageLog.logMessage(self.tr(message), TAB_LOG_QGIS, level=Qgis.Critical)
        QMessageBox.warning(None
            ,'ERROR'
            , self.tr(message))
        print('ERROR: '+self.tr(message))












##################################################################################################################################
## Funzioni associate ai click sui componenti della dialog
##################################################################################################################################

    #######################################################################################
    # Funzione per la gestione dei soggetti
    #######################################################################################
    def ricerca_soggetti(self,lingua):
        try:
            resp = requests.get(IRDAT_CATALOG_API+'/soggetti/search?lang='+lingua)
            # popolamento comboBox soggetti
            self.soggetti_comboBox.addItem ('', None)
            # recuperare lalista dei soggetti
            for org in resp.json():
                self.soggetti_comboBox.addItem(org['organizationName']['selected'],org['id'])
            self.message_info('Caricate ' + str(len(resp.json())) + ' organizzazioni')

            # abilitazione componenti dialog: dopo l''inizio della consultazione si attiva 
            # il bottone di ricerca e si disabilita quello di inizio connessione
            self.inizia_consultazione_pushButton.setEnabled(False)
            self.soggetti_comboBox.setEnabled(True)
            self.testo_lineEdit.setEnabled(True)
            self.lingua_comboBox.setEnabled(True)
            self.ricerca_pushButton.setEnabled(True)
            self.testo_lineEdit.setFocus()

        except:
            self.message_error('Risorsa non disponibile : GET /soggetti/search - ' + str(sys.exc_info()[0]))
    
    #######################################################################################
    # Funzione per la gestione del bottone di inizio consultazione
    #######################################################################################
    def inizia_consultazione_pushButton_clicked (self):
        self.message_info('Connessione al catalogo...')
        # svuotamento combobox, se era già stata popolata
        self.soggetti_comboBox.clear()
        # caricamento dei soggetti
        self.ricerca_soggetti(self.language)



    #######################################################################################
    # Funzione per la gestione del bottone della lingua
    #######################################################################################
    def lingua_comboBox_changed(self,int):
        self.language = LINGUE[int]
        self.inizia_consultazione_pushButton_clicked()
        self.message_info("Modificata lingua della ricerca: "+self.language)


    #######################################################################################
    # Funzione per la gestione della ricerca e dei suoi risultati 
    #######################################################################################
    def ricerca_elementi(self,stringa_ricerca,soggetto_ricerca,lingua):
        try:
            request_string = IRDAT_CATALOG_API+'/search' 
            payload = {}
            payload['lang'  ] = lingua
            if len(stringa_ricerca)>0:
                payload['txtAnyWhere'  ] = True
                payload['txtExact'     ] = True
                payload['txtInAltTitle'] = True
                payload['txtInColl'    ] = True
                payload['txtInKwd'     ] = True
                payload['txtInMdTitle' ] = True
                payload['txtInSyn'     ] = True
                payload['txtInTitle'   ] = True
                payload['txtInTopic'   ] = True
                payload['txtSearch'    ] = stringa_ricerca   
            if soggetto_ricerca != None:             
                payload['idRespParty'] = soggetto_ricerca 
            resp = requests.get(request_string, params=payload)

            # popolazione tableWidget
            numrows = len(resp.json())   
            self.tableWidget.setRowCount(numrows)
            # Loops per l'aggiunta dei valori
            row = 0
            for layer in resp.json():
                id_layer = layer['id']
                title = layer['title']['selected']
                abstract = layer['abs']['selected']
                tipo = layer['tipo']
                wfs = ''
                if (tipo=='WFS'): 
                    request2_string = IRDAT_CATALOG_API+'/services/'+str(id_layer)+'/connect-points?lang='+lingua
                    resp2 = requests.get(request2_string)
                    if resp2.status_code == 200:
                        for layer_wfs in resp2.json():
                            op = layer_wfs['operation']
                            if op == 'GetFeature':
                                wfs = layer_wfs['url']
                                self.tableWidget.setRowCount(row+1)
                                self.tableWidget.setItem(row, 0, QTableWidgetItem(str(title)))
                                self.tableWidget.setItem(row, 1, QTableWidgetItem(str(abstract)))
                                self.tableWidget.setItem(row, 2, QTableWidgetItem(str(id_layer)))
                                self.tableWidget.setItem(row, 3, QTableWidgetItem(str(wfs)+ '&srsName=EPSG:6708'))  
                                row = row + 1       
            self.tableWidget.setRowCount(row) # per risolvere situazioni in cui non ci sono layer WFS completi di getFeature       
            self.message_info('Caricati ' + str(row) + ' layers' + ' (analizzati ' + str(numrows) + ')')

        except:
            self.message_error('Errore ricerca elementi: '+str(sys.exc_info()[0]))

    #######################################################################################
    # Funzione per l'avvio della ricerca:
    # - controllo dei parametri
    # - avvio ricerca
    #######################################################################################
    def ricerca_pushButton_clicked(self):
        # recupero e controllo dei parametri per la ricerca
        current_index = self.soggetti_comboBox.currentIndex()
        soggetto_ricerca = None
        if current_index > 0:
            soggetto_ricerca = self.soggetti_comboBox.itemData(current_index)
        elif current_index < 0:   # solo per print di debug
            soggetto_ricerca = 'Soggetto non selezionato!' 
        stringa_ricerca = self.testo_lineEdit.text()
        soggetto_ricerca2 = str(soggetto_ricerca) 
        # controllo parametri
        if current_index < 0:
            if stringa_ricerca == '':
                self.message_warning('Specificare almeno un parametro di ricerca (testo ricerca / soggetto)')
                return
            elif len(stringa_ricerca) < 3:
                self.message_warning('Specificare almeno 3 caratteri come testo di ricerca')
                return
            soggetto_ricerca2 = 'None' # aggiunto solo per il debug
        
        # svuotamento tabella se era già stata popolata
        self.tableWidget.setRowCount(0)

        # disabilita bottoni perchè si necessita di una nuova selezione
        self.visualizza_metadati_pushButton.setEnabled(False)
        self.carica_layer_pushButton.setEnabled(False)
        self.carica_layer_MD_pushButton.setEnabled(False)

        self.message_info('Ricerca e caricamento elementi nella tabella (search: '+ stringa_ricerca + ', '+ soggetto_ricerca2 +')...')

        if self.so_info=='Linux':
            # evita il problema di Linux con i thread
            self.ricerca_elementi(stringa_ricerca,soggetto_ricerca,self.language)
        else:
            # Esecuzione via thread per evitare ritardi nella visualizzazione del messaggio informativo precedente
            te = Thread(target=self.ricerca_elementi, args=(stringa_ricerca,soggetto_ricerca,self.language) ) 
            te.start()














    #######################################################################################
    # Funzione per il caricamento dei metadati del layer selezionato
    #######################################################################################
    def caricamento_metadati(self):
        # parametri da passare al servizio
        if self.sel_layer_id == None:
            self.message_warning('Non risulta selezionato alcun layer')
            return None
        else:
            if (self.sel_layer_title==None or self.sel_layer_wfs==None):
                self.message_warning('Selezione non individuata')
                return None
            else:   
                try:
                    url_str = 'http://irdat.regione.fvg.it/consultatore-dati-ambientali-territoriali/detail/irdat/'+self.sel_layer_id+'/direct'
                    
                    url = QUrl(url_str)
                    query = QUrlQuery()
                    query.addQueryItem("language", self.language)
                    url.setQuery(query)
                    self.metadata_webView.load(url)
                    self.message_info('Caricati metadati ('+ url.toString() +')')
                    # attivazione bottone per l'apertura del web browser
                    self.apri_webbrowser_pushButton.setEnabled(True)
                    return url
                except:
                    self.message_warning('Metadati non disponibili (riselezionare il layer dall''elenco dei layer)')

    #######################################################################################
    # Funzione per la visualizzazione della sezione del metadati
    #######################################################################################
    def visualizza_metadata_pushButton_clicked(self):
        # apre il tab metadata_tab
        self.tabWidget.setCurrentIndex(1)

    #######################################################################################
    # Funzione per l'apertura dei metadati nel browser
    #######################################################################################
    def apri_webbrowser_pushButton_clicked(self):
        try:
            url_str = 'http://irdat.regione.fvg.it/consultatore-dati-ambientali-territoriali/detail/irdat/'+self.sel_layer_id+'/direct'
            url = QUrl(url_str)
            query = QUrlQuery()
            query.addQueryItem("language", self.language)
            url.setQuery(query)
            webbrowser.open(url.toString(), new = 1)
            self.message_info('Apertura web browser con i metadati ('+ url.toString() +')')
        except:
            self.message_warning('Problema caricamento metadati nel web browser')

    



    #######################################################################################
    # Funzione per la gestione della modifica della tableWidget con l'elenco dei layer
    #######################################################################################
    def layer_tableWidget_changed(self):
        current_row = self.tableWidget.currentRow()
        if (current_row>-1): 
            # salvataggio dati layer selezionato
            self.sel_layer_id = self.tableWidget.item(current_row, 2).text()
            self.sel_layer_title = self.tableWidget.item(current_row, 0).text()
            self.sel_layer_wfs = self.tableWidget.item(current_row, 3).text()  
            self.sel_item = current_row
            self.message_info('Avvio caricamento metadati ...')
            if (self.caricamento_metadati() == None):
                self.message_warning('Errore di caricamento dei metadati (riselezionare il layer)')
            # abilitazione componenti dialog
            # dopo la selezione di un layer si attiva i bottoni per la visualizzazione dei metadati e del caricamento
            self.visualizza_metadati_pushButton.setEnabled(True)
            self.carica_layer_pushButton.setEnabled(True)
            self.carica_layer_MD_pushButton.setEnabled(True)
            self.apri_webbrowser_pushButton.setEnabled(True)
        else:
            # disabilita bottoni perchè si necessita di una nuova selezione 
            self.visualizza_metadati_pushButton.setEnabled(False)
            self.carica_layer_pushButton.setEnabled(False)
            self.carica_layer_MD_pushButton.setEnabled(False)

    #######################################################################################
    # Funzione per il caricamento del layer WFS nel progetto QGIS
    #######################################################################################
    def carica_layer_wfs(self,layer_wfs,titolo,progettoQGIS):
        try:
            # creazione e caricamento del layer
            layerWFS = QgsVectorLayer(layer_wfs, titolo, "WFS")
            if not layerWFS.isValid():
                QMessageBox.warning(None
                    , 'Warning' # tr('Errore imprevisto')
                    , "Layer failed to load!")
            else:
                progettoQGIS.addMapLayer(layerWFS, True)
                self.message_info('Caricato layer ('+layer_wfs+')')
        except:
            self.message_error('Errore di caricamento del layer')

    #######################################################################################
    # Funzione per la gestione del bottone di caricamento del layer selezionato
    #######################################################################################
    def carica_layer_pushButton_clicked(self):
        # parametri da passare al servizio
        if self.sel_layer_id == None:  
            self.message_warning('Non risulta selezionato alcun layer')
        else:
            if (self.sel_layer_title==None or self.sel_layer_wfs==None):
                self.message_warning('Selezione non individuata')
            else:   
                self.message_info('Caricamento WFS layer...')
                self.carica_layer_wfs(self.sel_layer_wfs,self.sel_layer_title,QgsProject.instance())
               
                






    #######################################################################################
    # Funzione per la gestione del log
    #######################################################################################
    def log_comboBox_changed(self):
        self.log_tab_level = self.log_comboBox.currentIndex()
        self.message_info('Selezionato livello log: '+LIVELLO_LOG_COMBOBOX[self.log_tab_level])
        # scansione lista di supporto per la visualizzazione del livello selezionato
        self.log_listWidget.clear()
        for item in self.log_list:
            if (self.log_tab_level==0 or item[0]==self.log_tab_level-1):
                self.log_listWidget.addItem(item[1])





    #######################################################################################
    # Funzione per la gestione del bottone di chiusura della finestra
    #######################################################################################
    def chiudi_pushButton_clicked(self):
        self.message_info('Chiusura dialog')
        self.close()

